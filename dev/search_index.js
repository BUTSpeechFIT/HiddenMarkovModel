var documenterSearchIndex = {"docs":
[{"location":"fsm/#Finite-State-Machines","page":"Finite State Machines","title":"Finite State Machines","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"The MarkovModels package represents Markov chains as probabilistic Finite State Machine (FSMs). Here is an example of FSM as used by the package:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: alternative text)","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"The double edge circle node with the label \"<s>\" (respectively \"</s>\") is the initial (respectively final) state of the FSM. States with light blue background color are emitting states, that is, they are associated with a probability density function index (pdfindex). If they have no label, this index is use when displaying the node - as in the example above. White circle node with a label written inside are non-emitting labeled states. The states represented as point are neither emitting nor have a label. Finally, the number on the links are the log-probabilities to move from one state to another.","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"note: Note\nTo be able to visualize FSMs as in the example above when using IJulia, make sure that the dot program (from graphviz) is available in your shell PATH variable. Also, you won't be able to visualize the FSM in the REPL.","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"In the following, we present the tools provided by the MarkovModels package manipulate such FSM. All the examples below assume that you have already imported the MarkovModels package by doing using MarkovModels.","category":"page"},{"location":"fsm/#Creating-FSMs","page":"Finite State Machines","title":"Creating FSMs","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"The first step is to create an FSM object.","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"fsm = FSM()","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: alternative text)","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"When created, the FSM has only two states: the initial state and the final state. In the MarkovModels, FSMs cannot have multiple initial for final states.","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"You can add states to the FSM by using the function addstate!:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"s1 = addstate!(fsm, pdfindex = 1)\ns2 = addstate!(fsm, pdfindex = 2, label = \"a\")\ns3 = addstate!(fsm, label = \"b\")\ns4 = addstate!(fsm)","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: alternative text)","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Note that a state can be:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"emitting and labeled\nemitting only\nlabeled only\nnon-emitting and non-labeled (nil state)","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"The initial and final states are specific nil states.","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"The link! allows to add weighted arcs between states:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"link!(fsm, initstate(fsm), s1)\nlink!(fsm, s1, s1, log(1/2))\nlink!(fsm, s1, s2, log(1/2))\nlink!(fsm, s2, s3)\nlink!(fsm, s3, s4)\nlink!(fsm, s4, finalstate(fsm))","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: alternative text)","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Finally, we provide a special constructor for convenience:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"LinearFSM(::AbstractArray{<:Label}, ::Dict{<:Label, <:Pdfindex})","category":"page"},{"location":"fsm/#MarkovModels.LinearFSM-Tuple{AbstractArray{#s1,N} where N where #s1<:Union{Nothing, AbstractString},Dict{#s2,#s3} where #s3<:Union{Nothing, Int64} where #s2<:Union{Nothing, AbstractString}}","page":"Finite State Machines","title":"MarkovModels.LinearFSM","text":"LinearFSM(seq[, emissionsmap::Dict{<:Label, <:Pdfindex}])\n\nCreate a linear FSM from a sequence of labels seq. If emissionsmap is provided, every item l of seq with a matching entry in emissionsmap will be assigned the pdf index emissionsmap[l].\n\n\n\n\n\n","category":"method"},{"location":"fsm/#FSM-operations","page":"Finite State Machines","title":"FSM operations","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"CurrentModule = MarkovModels","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"addselfloop!(::FSM, ::Real)\ncompose!(::FSM, ::Dict{Label, FSM})\nconcat(::FSM, ::FSM)\nminimize!(::FSM)\nremovenilstates!(::FSM)\nBase.union(::FSM, ::FSM)\nweightnormalize!(::FSM)","category":"page"},{"location":"fsm/#MarkovModels.addselfloop!-Tuple{FSM,Real}","page":"Finite State Machines","title":"MarkovModels.addselfloop!","text":"addselfloop!(fsm[, looplogprob = log(1/2)])\n\nAdd a self-loop to all emitting states of fsm. looplogprob is the log-probability of self-transition.\n\nExamples\n\njulia> fsm = LinearFSM([\"a\", \"b\", \"c\"], Dict(\"a\" => 1, \"b\" => 2))\njulia> addselfloop!(fsm, log(1/4))\n\nInput:\n\n(Image: See the online documentation to visualize the image)\n\nOutput:\n\n(Image: See the online documentation to visualize the image)\n\njulia> fsm = LinearFSM([\"a\", \"b\", \"c\"], Dict(\"a\" => 1, \"b\" => 2))\njulia> fsm |> addselfloop!\n\nInput:\n\n(Image: See the online documentation to visualize the image)\n\nOutput:\n\n(Image: See the online documentation to visualize the image)\n\n\n\n\n\n","category":"method"},{"location":"fsm/#MarkovModels.compose!-Tuple{FSM,Dict{Union{Nothing, AbstractString},FSM}}","page":"Finite State Machines","title":"MarkovModels.compose!","text":"compose!(fsm, subfsms)\n\nReplace each state s in fsm by a \"subfsms\" from subfsms with associated label s.label. subfsms should be a Dict{<:Label, FSM}`.\n\nExamples\n\njulia> fsm = union(LinearFSM([\"a\", \"b\"]), LinearFSM([\"c\"])) |> weightnormalize!\njulia> subfsms = subfsms = Dict(\n    \"a\" => LinearFSM([\"a1\", \"a2\", \"a3\"], Dict(\"a1\"=>1, \"a2\"=>2, \"a3\"=>3)) |> addselfloop!,\n    \"b\" => LinearFSM([\"b1\", \"b2\"], Dict(\"b1\"=>4, \"b2\"=>5)) |> addselfloop!,\n    \"c\" => LinearFSM([\"c1\", \"c2\"], Dict(\"c1\"=>6, \"c2\"=>1)) |> addselfloop!\n)\njulia> compose!(fsm, sufsms)\n\nInput :\n\nfsm\n\n(Image: See the online documentation to visualize the image)\n\nsubfsms[\"a\"]\n\n(Image: See the online documentation to visualize the image)\n\nsubfsms[\"b\"]\n\n(Image: See the online documentation to visualize the image)\n\nsubfsms[\"c\"]\n\n(Image: See the online documentation to visualize the image) Output:   (Image: See the online documentation to visualize the image)\n\nAlternatively, FSMs can be composed with the ∘ operator:\n\njulia> fsm ∘ sufsms\n\nWhen using the ∘ operator, the composition is not performed in place.\n\n\n\n\n\n","category":"method"},{"location":"fsm/#MarkovModels.concat-Tuple{FSM,FSM}","page":"Finite State Machines","title":"MarkovModels.concat","text":"concat(fsm1, fsm2, ...)\n\nConcatenate several FSMs into single FSM.\n\nExamples\n\njulia> fsm1 = LinearFSM([\"a\", \"b\"])\njulia> fsm2 = LinearFSM([\"c\", \"d\"])\njulia> fsm3 = LinearFSM([\"e\"])\njulia> concat(fsm1, fsm2, fsm3)\n\nInput:\n\nfsm1\n\n(Image: See the online documentation to visualize the image)\n\nfsm2\n\n(Image: See the online documentation to visualize the image)\n\nfsm3\n\n(Image: See the online documentation to visualize the image)\n\nOutput:   (Image: See the online documentation to visualize the image)\n\n\n\n\n\n","category":"method"},{"location":"fsm/#MarkovModels.minimize!-Tuple{FSM}","page":"Finite State Machines","title":"MarkovModels.minimize!","text":"minimize!(fsm)\n\nMerge equivalent states such to reduce the size of the FSM. Only the states that have the same pdfindex and the same label can be potentially merged.\n\nwarning: Warning\nThe input FSM should not contain cycles otherwise the algorithm will never end.\n\nExamples\n\njulia> fsm = union(LinearFSM([\"a\", \"b\", \"c\"], Dict(\"a\"=>1)), LinearFSM([\"a\", \"d\", \"c\"], Dict(\"a\"=>1)))\njulia> fsm |> minimize!\n\nInput:\n\n(Image: See the online documentation to visualize the image)\n\nOutput:\n\n(Image: See the online documentation to visualize the image)\n\n\n\n\n\n","category":"method"},{"location":"fsm/#MarkovModels.removenilstates!-Tuple{FSM}","page":"Finite State Machines","title":"MarkovModels.removenilstates!","text":"removenilstates!(fsm)\n\nRemove all states that are non-emitting and have no labels (except the the initial and final states)\n\nExamples\n\njulia> fsm = LinearFSM([\"a\", \"b\"], Dict(\"a\" => 1))\njulia> nil = addstate!(fsm)\njulia> link!(fsm, initstate(fsm), nil)\njulia> link!(fsm, nil, finalstate(fsm))\njulia> fsm = fsm |> weightnormalize!\njulia> fsm |> removenilstates!\n\nInput:\n\n(Image: See the online documentation to visualize the image)\n\nOuput:\n\n(Image: See the online documentation to visualize the image)\n\n\n\n\n\n","category":"method"},{"location":"fsm/#Base.union-Tuple{FSM,FSM}","page":"Finite State Machines","title":"Base.union","text":"union(fsm1, fsm2, ...)\n\nMerge several FSMs into a single one.\n\nExamples\n\njulia> fsm1 = LinearFSM([\"a\", \"b\", \"c\"], Dict(\"a\"=>1))\njulia> fsm2 = LinearFSM([\"a\", \"d\", \"c\"], Dict(\"a\"=>1))\njulia> union(fsm1, fsm2)\n\nInput:\n\nfsm1\n(Image: See the online documentation to visualize the image)\nfsm2\n(Image: See the online documentation to visualize the image)\n\nOutput:\n\n(Image: See the online documentation to visualize the image)\n\n\n\n\n\n","category":"method"},{"location":"fsm/#MarkovModels.weightnormalize!-Tuple{FSM}","page":"Finite State Machines","title":"MarkovModels.weightnormalize!","text":"weightnormalize!(fsm)\n\nChange the weight of the links such that the sum of the exponentiated weights of the outgoing links from one state will sum up to one.\n\nExamples\n\njulia> fsm = union(LinearFSM([\"a\", \"b\"]), LinearFSM([\"c\", \"d\"]))\njulia> for s in states(fsm)\n    if ! isinit(s) && ! isfinal(s)\n        link!(fsm, s, s)\n    end\nend\njulia> fsm |> weightnormalize!\n\nInput:\n\n(Image: See the online documentation to visualize the image)\n\nOutput:\n\n(Image: See the online documentation to visualize the image)\n\nnote: Note\nThis function has the side effect to \"determinize\" the FSM, that is, the resulting FSM will have at most one arc between each pair of node.\n\n\n\n\n\n","category":"method"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/#Installation-of-Julia","page":"Installation","title":"Installation of Julia","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"The MarkovModels package was developped and tested with Julia 1.5.0. If you haven't installed Julia already, follow the instruction here.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"tip: Tip\nIt is a common practice in Julia to use non-ascii characters while coding such as greek letters or mathematical symbols. We highly recommend to add Julia support to your editor to easily access these special characters. Plugin for vim/neovim and emacs can be found here.","category":"page"},{"location":"install/#Installation-of-MarkovModels","page":"Installation","title":"Installation of MarkovModels","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"In the Julia REPL prompt, press ] to enther the Pkg REPL and then type:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"(@v1.5) pkg> add https://github.com/BUTSpeechFIT/MarkovModels","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"This will install the package and its dependencies into your Julia installation.","category":"page"},{"location":"#MarkovModels-Documentation","page":"Home","title":"MarkovModels Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MarkovModels is a Julia package to use (Hidden) Markov Models for probabilistic inference.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Lucas Ondel, Brno University of Technology\nMartin Kocour, Brno University of Technology","category":"page"},{"location":"#Reference","page":"Home","title":"Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TODO: Add DOI","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"install.md\", \"fsm.md\"]","category":"page"}]
}

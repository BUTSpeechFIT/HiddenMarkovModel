var documenterSearchIndex = {"docs":
[{"location":"fsm/#Finite-State-Machines","page":"Finite State Machines","title":"Finite State Machines","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"CurrentModule = MarkovModels","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"The MarkovModels package represents Markov chains as probabilistic a Finite State Machine (FSM).  Here is an example of FSM as used by the package:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: )","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"The double edge circle node with the label \"<s>\" (respectively \"</s>\") is the initial (respectively final) state of the FSM. States with light blue background color are emitting states, that is, they are associated with a probability density function index (pdfindex). If they have no label, this index is use when displaying the node - as in the example above. White circle node with a label written inside are non-emitting labeled states. The states represented as point are neither emitting nor have a label. Finally, the number on the links are the log-probabilities to move from one state to another.","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"note: Note\nTo be able to visualize FSMs as in the example above when using IJulia, make sure that the dot program (from graphviz) is available in your shell PATH variable. Also, you won't be able to visualize the FSM in the REPL.","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"In the following, we present the tools provided by the package manipulate such FSM. All the examples below assume that you have already imported the MarkovModels package by doing using MarkovModels.","category":"page"},{"location":"fsm/#Creating-FSMs","page":"Finite State Machines","title":"Creating FSMs","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"FSMs are represented by the following structure:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"FSM","category":"page"},{"location":"fsm/#MarkovModels.FSM","page":"Finite State Machines","title":"MarkovModels.FSM","text":"struct FSM{T}\n    ...\nend\n\nStructure of a FSM. The type T indicates the type of the arcs' weight.\n\n\n\n\n\n","category":"type"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"To create an FSM object simply type:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"fsm = FSM{Float64}()","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: alternative text)","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"When created, the FSM has only two states: the initial state and the final state. FSMs cannot have multiple initial for final states.","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"You can add states to the FSM by using the function addstate!:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"s1 = addstate!(fsm, pdfindex = 1)\ns2 = addstate!(fsm, pdfindex = 2, label = \"a\")\ns3 = addstate!(fsm, label = \"b\")\ns4 = addstate!(fsm)","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: alternative text)","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Note that a state can be:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"emitting and labeled\nemitting only\nlabeled only\nnon-emitting and non-labeled (nil state)","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"The initial and final states are specific nil states.","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"The link! allows to add weighted arcs between states:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"link!(initstate(fsm), s1)\nlink!( s1, s1, log(1/2))\nlink!(s1, s2, log(1/2))\nlink!(s2, s3)\nlink!(s3, s4)\nlink!(s4, finalstate(fsm))","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: alternative text)","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Finally, we provide a special constructor for convenience:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"LinearFSM","category":"page"},{"location":"fsm/#MarkovModels.LinearFSM","page":"Finite State Machines","title":"MarkovModels.LinearFSM","text":"LinearFSM([T, ]seq[, emissionsmap::Dict{<:Label, <:PdfIndex}])\n\nCreate a linear FSM of type T from a sequence of labels seq. If emissionsmap is provided, every item l of seq with a matching entry in emissionsmap will be assigned the pdf index emissionsmap[l]. PdfIndex can be any integer type and Label any string type.\n\n\n\n\n\n","category":"function"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"For instance,","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"fsm = LinearFSM(Float32, [\"a\", \"b\", \"c\"], Dict(\"a\" => 1, \"b\" => 2, \"c\" => 3))","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: )","category":"page"},{"location":"fsm/#States","page":"Finite State Machines","title":"States","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"State\nisemitting\nisinit\nisfinal\nislabeled\nlinks(::AbstractState)\nnextemittingstates","category":"page"},{"location":"fsm/#MarkovModels.State","page":"Finite State Machines","title":"MarkovModels.State","text":"struct State\n    id\n    pdfindex\n    label\nend\n\nState of a FSM.\n\nid is the unique identifier of the state within a FSM.\npdfindex is the index of a probability density associated to the  state. If the state is non-emitting, pdfindex is equal to  nothing.\nlabel is a readable name (either String or Nothing).\n\nExamples\n\njulia> State(1)\nState(1)\njulia> State(1, pdfindex = 2)\nState(1, pdfindex = 2)\n\n\n\n\n\n","category":"type"},{"location":"fsm/#MarkovModels.isemitting","page":"Finite State Machines","title":"MarkovModels.isemitting","text":"isemitting(state)\n\nReturns true if state a pdf index associated.\n\n\n\n\n\n","category":"function"},{"location":"fsm/#MarkovModels.isinit","page":"Finite State Machines","title":"MarkovModels.isinit","text":"isinit(state)\n\nReturns true if the state is the initial state of the FSM.\n\n\n\n\n\n","category":"function"},{"location":"fsm/#MarkovModels.isfinal","page":"Finite State Machines","title":"MarkovModels.isfinal","text":"isfinal(state)\n\nReturns true if the state is the final state of the FSM.\n\n\n\n\n\n","category":"function"},{"location":"fsm/#MarkovModels.islabeled","page":"Finite State Machines","title":"MarkovModels.islabeled","text":"islabeled(state)\n\nReturns true if the state has a label.\n\n\n\n\n\n","category":"function"},{"location":"fsm/#MarkovModels.links-Tuple{MarkovModels.AbstractState}","page":"Finite State Machines","title":"MarkovModels.links","text":"links(state)\n\nIterator over the links to the children (i.e. next states) of state.\n\n\n\n\n\n","category":"method"},{"location":"fsm/#MarkovModels.nextemittingstates","page":"Finite State Machines","title":"MarkovModels.nextemittingstates","text":"nextemittingstates(fsm, state)\n\nIterator over the next emitting states. For each value, the iterator return a tuple (nextstate, weightpath, path). The weight path is the sum of the weights for all the link to reach nextstate. Path is a vector of links between state and nextstate.\n\n\n\n\n\n","category":"function"},{"location":"fsm/#Links","page":"Finite State Machines","title":"Links","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Link","category":"page"},{"location":"fsm/#MarkovModels.Link","page":"Finite State Machines","title":"MarkovModels.Link","text":"struct Link{T}\n    src::T where T<:AbstractState\n    dest::D where T<:AbstractState\n    weight::T\nend\n\nWeighted link pointing from a state src to a state dest with weight weight.  T is the type of the weight value. The weight represents the log-probability of going through this link.\n\n\n\n\n\n","category":"type"},{"location":"fsm/#Iterating-over-states-and-links","page":"Finite State Machines","title":"Iterating over states and links","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"    initstate\n    finalstate\n    links\n    states","category":"page"},{"location":"fsm/#MarkovModels.initstate","page":"Finite State Machines","title":"MarkovModels.initstate","text":"initstate(fsm)\n\nReturns the initial state of fsm.\n\n\n\n\n\n","category":"function"},{"location":"fsm/#MarkovModels.finalstate","page":"Finite State Machines","title":"MarkovModels.finalstate","text":"finalstate(fsm)\n\nReturns the final state of fsm.\n\n\n\n\n\n","category":"function"},{"location":"fsm/#MarkovModels.links","page":"Finite State Machines","title":"MarkovModels.links","text":"links(state)\n\nIterator over the links to the children (i.e. next states) of state.\n\n\n\n\n\nlinks(fsm)\n\nReturns the list of the links of the FSM.\n\n\n\n\n\n","category":"function"},{"location":"fsm/#MarkovModels.states","page":"Finite State Machines","title":"MarkovModels.states","text":"states(fsm)\n\nIterator over the state of fsm.\n\n\n\n\n\n","category":"function"},{"location":"fsm/#FSM-operations","page":"Finite State Machines","title":"FSM operations","text":"","category":"section"},{"location":"fsm/#Composition","page":"Finite State Machines","title":"Composition","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"compose","category":"page"},{"location":"fsm/#MarkovModels.compose","page":"Finite State Machines","title":"MarkovModels.compose","text":"compose(subfsms::Dict, fsm)\nBase.:∘(subfsms::Dict, fsm)\n\nReplace each state s in fsm by a \"subfsms\" from subfsms with associated label s.label. subfsms should be a Dict{<:Label, FSM}`.\n\n\n\n\n\n","category":"function"},{"location":"fsm/#Example","page":"Finite State Machines","title":"Example","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"fsm = union(LinearFSM([\"a\", \"b\"]), LinearFSM([\"c\"])) |> weightnormalize\nsubfsms = subfsms = Dict(\n    \"a\" => LinearFSM([\"a1\", \"a2\", \"a3\"], Dict(\"a1\"=>1, \"a2\"=>2, \"a3\"=>3)),\n    \"b\" => LinearFSM([\"b1\", \"b2\"], Dict(\"b1\"=>4, \"b2\"=>5)),\n    \"c\" => LinearFSM([\"c1\", \"c2\"], Dict(\"c1\"=>6, \"c2\"=>1))\n)\ncompose(subfsms, fsm)","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Input :","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"fsm","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: )","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"subfsms[\"a\"]","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: )","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"subfsms[\"b\"]","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: )","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"subfsms[\"c\"]","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: ) Output:   (Image: )","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Alternatively, FSMs can be composed with the ∘ operator:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"fsm ∘ sufsms","category":"page"},{"location":"fsm/#Concatenation","page":"Finite State Machines","title":"Concatenation","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"concat","category":"page"},{"location":"fsm/#MarkovModels.concat","page":"Finite State Machines","title":"MarkovModels.concat","text":"concat(fsm1, fsm2, ...)\n\nConcatenate several FSMs into single FSM.\n\n\n\n\n\n","category":"function"},{"location":"fsm/#Example-2","page":"Finite State Machines","title":"Example","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"fsm1 = LinearFSM([\"a\", \"b\"])\nfsm2 = LinearFSM([\"c\", \"d\"])\nfsm3 = LinearFSM([\"e\"])\nconcat(fsm1, fsm2, fsm3)","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Input:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"fsm1","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: )","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"fsm2","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: )","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"fsm3","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: )","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Output:   (Image: )","category":"page"},{"location":"fsm/#Determinization","page":"Finite State Machines","title":"Determinization","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"determinize","category":"page"},{"location":"fsm/#MarkovModels.determinize","page":"Finite State Machines","title":"MarkovModels.determinize","text":"determinize(fsm)\n\nTransform fsm such that each state has at most one link to any other states.\n\n\n\n\n\n","category":"function"},{"location":"fsm/#Example-3","page":"Finite State Machines","title":"Example","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"fsm = FSM{Float64}()\ns1 = addstate!(fsm, label = \"a\")\ns2 = addstate!(fsm, label = \"b\", pdfindex = 1)\nlink!(s1, s2, log(1/2))\nlink!(s1, s2, log(1/2))\nlink!(initstate(fsm), s1)\nlink!(s2, finalstate(fsm))\nfsm |> determinize","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Input: (Image: )","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Output: (Image: )","category":"page"},{"location":"fsm/#Minimization","page":"Finite State Machines","title":"Minimization","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"minimize","category":"page"},{"location":"fsm/#MarkovModels.minimize","page":"Finite State Machines","title":"MarkovModels.minimize","text":"minimize(fsm)\n\nMerge equivalent states to reduce the size of the FSM. Only the states that have the same pdfindex and the same label can be potentially merged.\n\nwarning: Warning\nThe input FSM should not contain cycles otherwise the algorithm will never end.\n\n\n\n\n\n","category":"function"},{"location":"fsm/#Example-4","page":"Finite State Machines","title":"Example","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"fsm = union(LinearFSM([\"a\", \"b\", \"c\"], Dict(\"a\"=>1)), LinearFSM([\"a\", \"d\", \"c\"], Dict(\"a\"=>1)))\nfsm |> minimize","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Input:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: )","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Output:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: )","category":"page"},{"location":"fsm/#Nil-states-removal","page":"Finite State Machines","title":"Nil states removal","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"removenilstates","category":"page"},{"location":"fsm/#MarkovModels.removenilstates","page":"Finite State Machines","title":"MarkovModels.removenilstates","text":"removenilstates(fsm)\n\nRemove all states that are non-emitting and have no labels (except the the initial and final states)\n\n\n\n\n\n","category":"function"},{"location":"fsm/#Example-5","page":"Finite State Machines","title":"Example","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"fsm = LinearFSM([\"a\", \"b\"], Dict(\"a\" => 1))\nnil = addstate!(fsm)\nlink!(initstate(fsm), nil)\nlink!(nil, finalstate(fsm))\nfsm = fsm |> weightnormalize\nfsm |> removenilstates","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Input:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: )","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Ouput:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: )","category":"page"},{"location":"fsm/#Transposition","page":"Finite State Machines","title":"Transposition","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Base.transpose(::AbstractFSM{T}) where T","category":"page"},{"location":"fsm/#Base.transpose-Union{Tuple{MarkovModels.AbstractFSM{T}}, Tuple{T}} where T","page":"Finite State Machines","title":"Base.transpose","text":"transpose(fsm)\n\nTranspose the fsm, i.e. reverse all it's arcs. The final state becomes the initial state.\n\n\n\n\n\n","category":"method"},{"location":"fsm/#Example-6","page":"Finite State Machines","title":"Example","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"fsm = LinearFSM([\"a\", \"b\", \"c\"])\ntranspose(fsm)","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Input:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: )","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Output:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: )","category":"page"},{"location":"fsm/#Union","page":"Finite State Machines","title":"Union","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Base.union(::AbstractFSM{T}, ::AbstractFSM{T}) where T","category":"page"},{"location":"fsm/#Base.union-Union{Tuple{T}, Tuple{MarkovModels.AbstractFSM{T},MarkovModels.AbstractFSM{T}}} where T","page":"Finite State Machines","title":"Base.union","text":"union(fsm1, fsm2, ...)\n∪(fsm1, fsm2, ...)\n\nMerge several FSMs into a single one.\n\n\n\n\n\n","category":"method"},{"location":"fsm/#Example-7","page":"Finite State Machines","title":"Example","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"fsm1 = LinearFSM([\"a\", \"b\", \"c\"], Dict(\"a\"=>1))\nfsm2 = LinearFSM([\"a\", \"d\", \"c\"], Dict(\"a\"=>1))\nunion(fsm1, fsm2)","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Input:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"fsm1\n(Image: See the online documentation to visualize the image)\nfsm2\n(Image: See the online documentation to visualize the image)","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Output:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: )","category":"page"},{"location":"fsm/#Weights-normalization","page":"Finite State Machines","title":"Weights normalization","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"weightnormalize","category":"page"},{"location":"fsm/#MarkovModels.weightnormalize","page":"Finite State Machines","title":"MarkovModels.weightnormalize","text":"weightnormalize(fsm)\n\nChange the weight of the links such that the sum of the exponentiated weights of the outgoing links from one state will sum up to one.\n\n\n\n\n\n","category":"function"},{"location":"fsm/#Example-8","page":"Finite State Machines","title":"Example","text":"","category":"section"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"fsm = union(LinearFSM([\"a\", \"b\"]), LinearFSM([\"c\", \"d\"]))\nfor s in states(fsm)\n    if ! isinit(s) && ! isfinal(s)\n        link!(s, s)\n    end\nend\nfsm |> weightnormalize","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Input:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: )","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"Output:","category":"page"},{"location":"fsm/","page":"Finite State Machines","title":"Finite State Machines","text":"(Image: )","category":"page"},{"location":"#MarkovModels-Documentation","page":"Home","title":"MarkovModels Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MarkovModels is a Julia package to use (Hidden) Markov Models for probabilistic inference.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the project on github.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To quickly get started, have a look at our examples:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Building a simple ASR decoder\nBaum-Welch (forward-backward) algorithm","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Lucas Ondel, Brno University of Technology\nMartin Kocour, Brno University of Technology","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add MarkovModels","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"fsm.md\", \"inference.md\"]","category":"page"},{"location":"inference/#Inference","page":"Inference","title":"Inference","text":"","category":"section"},{"location":"inference/","page":"Inference","title":"Inference","text":"CurrentModule = MarkovModels","category":"page"},{"location":"inference/#Baum-Welch-algoritm-(forward-backward)","page":"Inference","title":"Baum-Welch algoritm (forward-backward)","text":"","category":"section"},{"location":"inference/","page":"Inference","title":"Inference","text":"The Baum-Welch algorithm computes the probability to be in a state i at time n:","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"p(z_n = i  x_1  x_N)","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"It is implemented by the αβrecursion and the resps functions.","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"αβrecursion\nresps","category":"page"},{"location":"inference/#MarkovModels.αβrecursion","page":"Inference","title":"MarkovModels.αβrecursion","text":"αβrecursion(fsm, llh[, pruning = nopruning])\n\nBaum-Welch algorithm per state in the log domain. This function returns a tuple (lnαβ, ttl) where lnαβ is a sparse representation of the responsibilities and ttl is the log-likelihood of the sequence given the inference fsm.\n\n\n\n\n\n","category":"function"},{"location":"inference/#MarkovModels.resps","page":"Inference","title":"MarkovModels.resps","text":"resps(fsm, lnαβ[, dense = false])\n\nConvert the output of the αβrecursion to the per-frame pdf responsibilities. The returned value is a dictionary whose keys are pdf indices.\n\n\n\n\n\n","category":"function"},{"location":"inference/#Example","page":"Inference","title":"Example","text":"","category":"section"},{"location":"inference/","page":"Inference","title":"Inference","text":"First, we create the inference FSM:","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"using MarkovModels\n\nemissionsmap = Dict(\n    \"a\" => 1,\n    \"b\" => 2,\n    \"c\" => 1\n)\n\nfsm = LinearFSM([\"a\", \"b\", \"c\"], emissionsmap)\nfor state in states(fsm)\n    (isinit(state) || isfinal(state)) && continue\n    link!(state, state)\nend\nfsm = fsm |> weightnormalize","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"(Image: )","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"Note that state \"a\" and \"c\" share the same emission pdf.","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"As we don't have real distributions/data we simply simulate some fake per-pdf and per-frame log-likelihood:","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"D, N = 2, 5 # number of pdfs, number of frames\nllh = randn(D, N)","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"Finally, we run the Baum-Welch algorithm:","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"lnαβ, ttl = αβrecursion(fsm, llh)\nγ = resps(fsm, lnαβ)\n\nusing Plots\np = plot()\nplot!(p, γ[1], label = \"p(z = 1|X)\")\nplot!(p, γ[2], label = \"p(z = 2|X)\")\nplot!(p, γ[3], label = \"p(z = 3|X)\")","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"(Image: )","category":"page"},{"location":"inference/#Getting-the-label-sequences","page":"Inference","title":"Getting the label sequences","text":"","category":"section"},{"location":"inference/","page":"Inference","title":"Inference","text":"To generate a label sequence from some data, you can either:","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"compute the most likely sequence of labels (see beststring)\ndraw a random sequence of label from p(Wx_1  x_N) where W is a sequence of labels of any length (see samplestring)","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"beststring\nsamplestring","category":"page"},{"location":"inference/#MarkovModels.beststring","page":"Inference","title":"MarkovModels.beststring","text":"beststring(fsm, llh[, pruning = nopruning, labelfilter = x -> true])\n\nReturns the best sequence of the labels given the log-likelihood llh.\n\n\n\n\n\n","category":"function"},{"location":"inference/#MarkovModels.samplestring","page":"Inference","title":"MarkovModels.samplestring","text":"samplestring(fsm, llh[, nsamples = 1, pruning = nopruning, labelfilter = x -> true])\n\nSample a sequence of labels given the log-likelihood llh.\n\n\n\n\n\n","category":"function"},{"location":"inference/#Pruning","page":"Inference","title":"Pruning","text":"","category":"section"},{"location":"inference/","page":"Inference","title":"Inference","text":"The inference functions (αβrecursion, beststring and samplestring) can be performed with a pruning strategy. This is necessary when the inference FSM is huge potentially leading to very long computational time. We propose two default strategies:","category":"page"},{"location":"inference/","page":"Inference","title":"Inference","text":"SafePruning\nThresholdPruning","category":"page"},{"location":"inference/#MarkovModels.SafePruning","page":"Inference","title":"MarkovModels.SafePruning","text":"struct ThresholdPruning\n    ...\nend\n\nPrune the states that cannot reach the final state before the end of the sequence.\n\nConstructor\n\nSafePruning(fsm)\n\n\n\n\n\n","category":"type"},{"location":"inference/#MarkovModels.ThresholdPruning","page":"Inference","title":"MarkovModels.ThresholdPruning","text":"struct ThresholdPruning\n    ...\nend\n\nPrune the active states (tokens) that have weights lower than the maximum weight at a given time frame minus a threshold Δ. The lower the threshold Δ the more the pruning:\n\nwhen Δ < 0 all paths are discarded, don't use negative threshold !!\nΔ == 0 greedy decoding, only keep the most likely state at each time step\nΔ = +∞ no pruning\n\nConstructor\n\nThresholdPruning(Δ)\n\n\n\n\n\n","category":"type"},{"location":"inference/","page":"Inference","title":"Inference","text":"warning: Warning\nThresholdPruning is not safe in the sense that it does not guarantee that, after pruning, a valid path will remain. You can build a safe threshold-based pruning by combining (in the given order) the two strategies:ThresholdPruning(100) ∘ SafePruning(fsm)","category":"page"}]
}
